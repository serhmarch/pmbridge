#############################################################################################
############################################ HELP ###########################################
#############################################################################################
# * LOG={[category],...}
#       Command for using log categories.
#
# 
# * MEMORY={<sz0x>,<sz1x>,<sz3x>,<sz4x>}
#       Command for inner memory configuration.
#       sz0x - size of coils (0x)-memory 
#       sz1x - size of input discretes (1x)-memory 
#       sz3x - size of input registers (3x)-memory 
#       sz4x - size of holding registers (4x)-memory
#
# 
# * SERVER={<type>,<name>,...}
# * CLIENT={<type>,<name>,...}
#       Command to create server and client port respectively.
#       * type - type of Modbus protocol of the port. Can be {RTU,ASC,TCP}
#       * name - name/id of the port. It is used for QUERY commands (client) and log
#
#       Types of port and parameters:
#       * SERVER={TCP,<name>,<tcpport>,<timeout>,<maxconn>} 
#           * tcpport - unnecessary parameter, server ModbusTCP port (502 by default)
#           * timeout - unnecessary parameter, timeout for read in milliseconds (3000 by default)
#           * maxconn - unnecessary parameter, maximum TCP connection for server (10 by default)
#
#       * CLIENT={TCP,<name>,<host>,<tcpport>,<timeout>} 
#	        * host    - remote host to connect
#	        * tcpport - unnecessary parameter, remote port to connect (502 by default)
#           * timeout - unnecessary parameter, timeout for read in milliseconds (3000 by default)
#
#       * SERVER={RTU,<name>,<devname>,<baudrate>,<databits>,<parity>,<stopbits>,<flowcontrol>,<timeoutfb>,<timeoutib>}
#         SERVER={ASC,<name>,<devname>,<baudrate>,<databits>,<parity>,<stopbits>,<flowcontrol>,<timeoutfb>,<timeoutib>}
#         CLIENT={RTU,<name>,<devname>,<baudrate>,<databits>,<parity>,<stopbits>,<flowcontrol>,<timeoutfb>,<timeoutib>}
#         CLIENT={ASC,<name>,<devname>,<baudrate>,<databits>,<parity>,<stopbits>,<flowcontrol>,<timeoutfb>,<timeoutib>}
#	        * devname     - device system name or port name. For example: COM13, /dev/ttyM0, /dev/ttyUSB0 etc
#	        * baudrate    - unnecessary parameter, baud rate, use from serie: 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200 (9600 by default)
#	        * databits    - unnecessary parameter, number of databits, use from serie: 5, 6, 7, 8  (8 by default)
#	        * parity      - unnecessary parameter, parity: None,N - none, Even,E - even, Odd,O - odd (None by default)
#	        * stopbits    - unnecessary parameter, stop bits: may be 1, 1.5 or 2 (1 by default)
#	        * flowcontrol - unnecessary parameter, flow control: No, Hard, Soft (No by default)
#           * timeoutfb   - unnecessary parameter, timeout for read first byte of the input packet in milliseconds (1000 by default)
#           * timeoutib   - unnecessary parameter, timeout for read next bytes of the input packet in milliseconds (50 by default)
#
#
# * QUERY={<client>,<unit>,<func>,<devadr>,<count>,<memadr>,<execpatt>,<succadr>,<errcadr>,<errvadr>}
#       Command for remote request for previously configured client port.
#       * client   - name of client port previously defined in CLIENT command
#       * unit     - modbus unit/address slave
#       * func     - name of function. Can be {RD,WR}. What to read/write defined in the next <devadr> parameter.
#       * devadr   - address of first item of the remote device to read/write
#       * count    - count of elements (discret or register)
#       * memadr   - address within inner memory to get/set
#       * execpatt - execution pattern. Specifies the query will be executed once at execpatt-cycle
#       * succadr  - address of success counter
#       * errcadr  - address of error counter
#       * errvadr  - address of last error
#
# * COPY={<srcadr>,<count>,<destadr>}
#       * srcadr  - memory address to copy from
#       * count   - count of elements to copy (discret or register)
#       * destadr - memory address to copy to
#
# * DELAY={<msec>}
#       * msec    - time to delay in milliseconds
#
# * DUMP={<memadr>,<count>,<format>}
#       * memadr  - memory address to print
#       * count   - count of elements to print (discret or register)
#       * format  - format of element. Must be:
#           * Bin16 
#           * Oct16 
#           * Dec16 
#           * UDec16
#           * Hex16 
#           * Bin32 
#           * Oct32 
#           * Dec32 
#           * UDec32
#           * Hex32 
#           * Bin64 
#           * Oct64 
#           * Dec64 
#           * UDec64
#           * Hex64 
#           * Float 
#           * Double
#
#
# `mpbridge` support 3 types of addressing format: 
#
# | Memory type       | Standard (1 based) | IEC 61131-3 (0 based)| IEC 61131-3 Hex (0 based)
# |-------------------|--------------------|----------------------|---------------------------
# | Coils             | `000001`           | `%Q0`                | `%Q0000h`                 
# | Discrete inputs   | `100016`           | `%I15`               | `%I000Fh`                
# | Input registers   | `300017`           | `%IW16`              | `%IW0010h`               
# | Holding registers | `406658`           | `%MW6657`            | `%MW1A01h`
#
#
#    
#############################################################################################
###################################### ERROR CODES ##########################################
#############################################################################################
#  MBR_OK                                  0
#  MBR_ILLEGAL_FUNCTION                    1
#  MBR_ILLEGAL_DATA_ADDRESS                2       
#  MBR_ILLEGAL_DATA_VALUE                  3
#  MBR_SLAVE_DEVICE_FAILURE                4
#  MBR_ACKNOWLEDGE                         5
#  MBR_SLAVE_DEVICE_BUSY                   6
#  MBR_NEGATIVE_ACKNOWLEDGE                7
#  MBR_MEMORY_PARITY_ERROR                 8
#  MBR_CMN_ERR_NO_RESPONSE                 32
#  MBR_CMN_ERR_NOT_CORRECT                 33
#  MBR_SERIAL_ERR_OPEN                     64
#  MBR_SERIAL_ERR_READ                     65
#  MBR_SERIAL_ERR_WRITE                    66
#  MBR_ASCII_ERR_MISS_COLON                72
#  MBR_ASCII_ERR_MISS_CRLF                 73
#  MBR_ASCII_ERR_BAD_CHAR                  74
#  MBR_ASCII_ERR_LRC                       75
#  MBR_RTU_ERR_CRC                         80
#  MBR_TCP_ERR_CONNECT                     128
#  MBR_TCP_ERR_RECV                        129
#  MBR_TCP_ERR_SEND                        130
#  MBR_UNKNOWN_ERROR                       255
#
#############################################################################################
##################################### CONFIG PARAMS #########################################
#############################################################################################

# Declaration. Memory with 1000 coils, 1000 input discretes, 1000 input registers and 5000 holding registers
MEMORY={1000,1000,1000,5000}

# Declaration. Port as TCP server with port 502, timeout 5000ms and max 10 connections
SERVER={TCP,serv,502,5000,10}

# Declaration. Port as RTU client with portname "/dev/ttyM0", baudrate 9600, 8 databits, no parity, 1 stopbits
CLIENT={RTU,client1,"/dev/ttyM0",
                    19200,
                    7,
                    E,
                    1.5,
                    Hard,
                    1000,
                    50}

# Declaration. Port as TCP server with port 502, timeout 5000ms and max 10 connections
CLIENT={TCP,client2,"127.0.0.1"}

# Execution. Write 10 holding register into remote device (from 400001 to 400010) with values of inner memory 300001 to 300010.
# Success counter is 300901, error counter is 300902 and last error code is 300903 within inner memory.
QUERY={client1,1,WR,400001,10,300001,1,300901,300902,300903}

# Execution. Print inner memory dump into console: 3 registers (from 300901 to 300903) in decimal format
DUMP={300901,3,Hex16}

# Execution. Wait 200 milliseconds
DELAY={200}

# Execution. Read 10 holding register from remote device (from 400001 to 400010) and put values into inner memory 400101 to 400110.
# Success counter is 300904, error counter is 300905 and last error code is 300906 within inner memory.
QUERY={client2,1,RD,%MW0,3,%MW100,1,300904,300905,300906}

# Execution. Print inner memory dump into console: 3 registers (from 300904 to 300906) in decimal format
DUMP={300904,3,Dec16}

# Execution. Copy 6 registers (previously defined counters) from inner memory 300901 to 300906 into inner memory 400001 to 400006
COPY={300901,6,%MW0000h}

# Execution. Wait 2 seconds (2000 milliseconds)
DELAY={2000}
