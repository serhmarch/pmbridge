#############################################################################################
############################################ HELP ###########################################
#############################################################################################
# * MEMORY={<sz0x>,<sz1x>,<sz3x>,<sz4x>}
#       sz0x - size of coils (0x)-memory 
#       sz1x - size of input discretes (1x)-memory 
#       sz3x - size of input registers (3x)-memory 
#       sz4x - size of holding registers (4x)-memory
#
# 
# * PORT={<name>,<side>,<type>,...}
#       name - name/id of the port. It is used in QUERY commands
#       side - side if bridges port. Can be {CLIENT,SERVER}
#       type - type of Modbus protocol of the port. Can be {RTU,ASC,TCP}
#
#       Types of PORT and parameters:
#       * PORT={<name>,SERVER,TCP,<tcpport>,<timeout>,<maxconn>} 
#           tcpport - server ModbusTCP port (502 by default)
#           timeout - timeout for read in milliseconds (5000 by default)
#           maxconn - maximum TCP connection for server (10 by default)
#
#       * PORT={<name>,CLIENT,TCP,<host>,<tcpport>,<timeout>} 
#	        tcpport - remote host to connect
#	        port    - remote port to connect
#           timeout - unnecessary parameter, timeout for read in milliseconds (5000 by default)
#
#       * PORT={<name>,SERVER,RTU,<devname>,<baudrate>,<databits>,<parity>,<stopbits>,<flowcontrol>,<timeoutfb>,<timeoutib>}
#         PORT={<name>,SERVER,ASC,<devname>,<baudrate>,<databits>,<parity>,<stopbits>,<flowcontrol>,<timeoutfb>,<timeoutib>}
#         PORT={<name>,CLIENT,RTU,<devname>,<baudrate>,<databits>,<parity>,<stopbits>,<flowcontrol>,<timeoutfb>,<timeoutib>}
#         PORT={<name>,CLIENT,ASC,<devname>,<baudrate>,<databits>,<parity>,<stopbits>,<flowcontrol>,<timeoutfb>,<timeoutib>}
#	        devname     - device system name or port name. For example: COM13, /dev/ttyM0, /dev/ttyUSB0 etc
#	        baudrate    - baud rate, use from serie: 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200
#	        databits    - number of databits, use from serie: 5, 6, 7, 8
#	        parity      - parity: 0,N - none, 1,E - even, 2,O - odd
#	        stopbits    - stop bits: may be 1 or 2
#	        flowcontrol - flow control: 0 - none, 1 - RTS/CTS, 2 - XON/XOFF
#           timeoutfb   - unnecessary parameter, timeout for read first byte of the input packet in milliseconds (1000 by default)
#           timeoutib   - unnecessary parameter, timeout for read next bytes of the input packet in milliseconds (50 by default)
#
#
# * QUERY={<client>,<unit>,<func>,<devadr>,<count>,<memadr>,<execpatt>,<succadr>,<errcadr>,<errvadr>}
#       client   - name of client port previously defined in PORT command
#       unit     - modbus unit/address slave
#       func     - name of function. Can be {RD,WR}. What to read/write defined in the next <devadr> parameter.
#       devadr   - address of first item of the remote device to read/write
#       count    - count of elements (discret or register)
#       memadr   - address within inner memory to get/set
#       execpatt - execution pattern. Specifies the query will be executed once at ic-cycle
#       succadr  - address of success counter
#       errcadr  - address of error counter
#       errvadr  - address of last error
#
# * COPY={<srcadr>,<count>,<destadr>}
#       srcadr  - memory address to copy from
#       count   - count of elements to copy (discret or register)
#       destadr - memory address to copy to
#
# * DELAY={<msec>}
#       <msec> - time to delay in milliseconds
#
# * DUMP={<memadr>,<count>,<format>}
#       memadr - memory address to print
#       count  - count of elements to print (discret or register)
#       format - format of element. Must be:
#           * Bin16 
#           * Oct16 
#           * Dec16 
#           * UDec16
#           * Hex16 
#           * Bin32 
#           * Oct32 
#           * Dec32 
#           * UDec32
#           * Hex32 
#           * Bin64 
#           * Oct64 
#           * Dec64 
#           * UDec64
#           * Hex64 
#           * Float 
#           * Double
#
#
# `mpbridge` support 3 types of addressing format: 
#
# | Memory type       | Standard (1 based) | IEC 61131-3 (0 based)| IEC 61131-3 Hex (0 based)
# |-------------------|--------------------|----------------------|---------------------------
# | Coils             | `000001`           | `%Q0`                | `%Q0000h`                 
# | Discrete inputs   | `100016`           | `%I15`               | `%I000Fh`                
# | Input registers   | `300017`           | `%IW16`              | `%IW0010h`               
# | Holding registers | `406658`           | `%MW6657`            | `%MW1A01h`
#
#
#    
#############################################################################################
###################################### ERROR CODES ##########################################
#############################################################################################
#  MBR_OK                                  0
#  MBR_ILLEGAL_FUNCTION                    1
#  MBR_ILLEGAL_DATA_ADDRESS                2       
#  MBR_ILLEGAL_DATA_VALUE                  3
#  MBR_SLAVE_DEVICE_FAILURE                4
#  MBR_ACKNOWLEDGE                         5
#  MBR_SLAVE_DEVICE_BUSY                   6
#  MBR_NEGATIVE_ACKNOWLEDGE                7
#  MBR_MEMORY_PARITY_ERROR                 8
#  MBR_CMN_ERR_NO_RESPONSE                 32
#  MBR_CMN_ERR_NOT_CORRECT                 33
#  MBR_SERIAL_ERR_OPEN                     64
#  MBR_SERIAL_ERR_READ                     65
#  MBR_SERIAL_ERR_WRITE                    66
#  MBR_ASCII_ERR_MISS_COLON                72
#  MBR_ASCII_ERR_MISS_CRLF                 73
#  MBR_ASCII_ERR_BAD_CHAR                  74
#  MBR_ASCII_ERR_LRC                       75
#  MBR_RTU_ERR_CRC                         80
#  MBR_TCP_ERR_CONNECT                     128
#  MBR_TCP_ERR_RECV                        129
#  MBR_TCP_ERR_SEND                        130
#  MBR_UNKNOWN_ERROR                       255
#
#############################################################################################
##################################### CONFIG PARAMS #########################################
#############################################################################################

# Declaration. Memory with 1000 coils, 1000 input discretes, 1000 input registers and 5000 holding registers
MEMORY={1000,1000,1000,5000}

# Declaration. Port as TCP server with port 502, timeout 5000ms and max 10 connections
PORT={SRV,SERVER,TCP,502,5000,10}

# Declaration. Port as RTU client with portname "/dev/ttyM0", baudrate 9600, 8 databits, no parity, 1 stopbits
PORT={client1,CLIENT,RTU,/dev/ttyM0,9600,8,N,1}

# Declaration. Port as TCP server with port 502, timeout 5000ms and max 10 connections
PORT={client2,CLIENT,TCP,192.168.100.205,502}

# Execution. Write 10 holding register into remote device (from 400001 to 400010) with values of inner memory 300001 to 300010.
# Success counter is 300901, error counter is 300902 and last error code is 300903 within inner memory.
QUERY={client1,1,WR,400001,10,300001,1,300901,300902,300903}

# Execution. Print inner memory dump into console: 3 registers (from 300901 to 300903) in decimal format
DUMP={300901,3,Dec16}

# Execution. Wait 200 milliseconds
DELAY={200}

# Execution. Read 10 holding register from remote device (from 400001 to 400010) and put values into inner memory 400101 to 400110.
# Success counter is 300901, error counter is 300902 and last error code is 300903 within inner memory.
QUERY={client2,1,RD,%MW0,3,%MW100,1,904,905,906}

# Execution. Print inner memory dump into console: 3 registers (from 300904 to 300906) in decimal format
DUMP={300904,3,Dec16}

# Execution. Copy 6 registers (previously defined counters) from inner memory 300901 to 300906 into inner memory 400001 to 400006
COPY={300901,6,%MW0000h}

# Execution. Wait 2000 milliseconds
DELAY={2000}
